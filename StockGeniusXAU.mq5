//+------------------------------------------------------------------+
//|                                                StockGeniusXAU.mq5 |
//|                      Generated by ChatGPT - MQL5 Expert Advisor  |
//+------------------------------------------------------------------+
#property copyright ""
#property link      ""
#property version   "1.00"
#property strict

#include <Trade/Trade.mqh>

CTrade trade;

int fast_ma_handle = INVALID_HANDLE;
int slow_ma_handle = INVALID_HANDLE;

input group "Paramètres de la Stratégie";
input int               Fast_MA_Period = 10;
input int               Slow_MA_Period = 30;
input ENUM_MA_METHOD    MA_Method      = MODE_EMA;
input ENUM_APPLIED_PRICE MA_Price      = PRICE_CLOSE;

input group "Gestion des Ordres";
input int    Stop_Loss_Pips   = 200;
input int    Take_Profit_Pips = 400;
input long   Magic_Number     = 2024001;

input group "Gestion du Risque";
input double Risk_Percent = 1.0;

int OnInit()
  {
   trade.SetExpertMagicNumber(Magic_Number);

   ResetLastError();
   fast_ma_handle = iMA(_Symbol,_Period,Fast_MA_Period,0,MA_Method,MA_Price);
   if(fast_ma_handle == INVALID_HANDLE)
     {
      PrintFormat("Erreur lors de la création de la moyenne mobile rapide (période %d). Code d'erreur : %d", Fast_MA_Period, GetLastError());
      return(INIT_FAILED);
     }

   ResetLastError();
   slow_ma_handle = iMA(_Symbol,_Period,Slow_MA_Period,0,MA_Method,MA_Price);
   if(slow_ma_handle == INVALID_HANDLE)
     {
      PrintFormat("Erreur lors de la création de la moyenne mobile lente (période %d). Code d'erreur : %d", Slow_MA_Period, GetLastError());
      return(INIT_FAILED);
     }

   return(INIT_SUCCEEDED);
  }

void OnDeinit(const int reason)
  {
   if(fast_ma_handle != INVALID_HANDLE)
     {
      IndicatorRelease(fast_ma_handle);
      fast_ma_handle = INVALID_HANDLE;
     }

   if(slow_ma_handle != INVALID_HANDLE)
     {
      IndicatorRelease(slow_ma_handle);
      slow_ma_handle = INVALID_HANDLE;
     }
  }

bool HasManagedPositionOpen(const string symbol)
  {
   const int positions_total = PositionsTotal();
   for(int index = 0; index < positions_total; ++index)
     {
      ulong ticket = PositionGetTicket(index);
      if(ticket == 0)
         continue;

      if(!PositionSelectByTicket(ticket))
         continue;

      if(PositionGetInteger(POSITION_MAGIC) != Magic_Number)
         continue;

      if(PositionGetString(POSITION_SYMBOL) != symbol)
         continue;

      return(true);
     }

   return(false);
  }

double CalculateLotSize(const int sl_pips)
  {
   if(sl_pips <= 0)
     {
      Print("Le Stop Loss doit être supérieur à zéro pour calculer la taille de lot.");
      return(0.0);
     }

   if(Risk_Percent <= 0.0)
     {
      Print("Le pourcentage de risque doit être supérieur à zéro.");
      return(0.0);
     }

   const double equity       = AccountInfoDouble(ACCOUNT_EQUITY);
   const double risk_amount  = equity * (Risk_Percent / 100.0);

   if(risk_amount <= 0.0)
     {
      Print("Impossible de calculer un montant de risque valide avec les paramètres actuels.");
      return(0.0);
     }

   double tick_value = 0.0;
   double tick_size  = 0.0;
   double volume_step = 0.0;
   double volume_min  = 0.0;
   double volume_max  = 0.0;
   double point_value = 0.0;

   if(!SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE, tick_value) ||
      !SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE, tick_size)  ||
      !SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP, volume_step)    ||
      !SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN, volume_min)      ||
      !SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX, volume_max)      ||
      !SymbolInfoDouble(_Symbol, SYMBOL_POINT, point_value))
     {
      Print("Impossible de récupérer les informations du symbole pour le calcul de la taille de lot.");
      return(0.0);
     }

   if(tick_value <= 0.0 || tick_size <= 0.0 || volume_step <= 0.0 || volume_max <= 0.0)
     {
      Print("Les propriétés du symbole retournent des valeurs invalides pour le calcul de la taille de lot.");
      return(0.0);
     }

   long digits_value = 0;
   if(!SymbolInfoInteger(_Symbol, SYMBOL_DIGITS, digits_value))
     {
      Print("Impossible de récupérer le nombre de décimales du symbole.");
      return(0.0);
     }

   const int digits = (int)digits_value;
   double pip_size   = point_value;

   if(digits == 3 || digits == 5)
      pip_size = point_value * 10.0;

   const double price_distance = MathAbs(sl_pips) * pip_size;
   if(price_distance <= 0.0)
      return(0.0);

   const double loss_per_lot = (price_distance / tick_size) * tick_value;
   if(loss_per_lot <= 0.0)
      return(0.0);

   const double raw_lot = risk_amount / loss_per_lot;
   if(raw_lot <= 0.0)
      return(0.0);

   const double step_ratio  = raw_lot / volume_step;
   const double steps_count = MathFloor(step_ratio + 1e-8);
   double normalized_lot    = steps_count * volume_step;

   string step_text = DoubleToString(volume_step, 8);
   int    dot_index = StringFind(step_text, ".");
   int    precision = 0;
   if(dot_index >= 0)
     {
      int last_index = StringLen(step_text) - 1;
      while(last_index > dot_index && StringGetCharacter(step_text, last_index) == '0')
         last_index--;

      precision = last_index - dot_index;
      if(precision < 0)
         precision = 0;
     }

   normalized_lot = NormalizeDouble(normalized_lot, precision);

   if(normalized_lot < volume_min)
     {
      PrintFormat("La taille de lot calculée (%.8f) est inférieure au minimum autorisé (%.8f) pour %s.",
                  normalized_lot,
                  volume_min,
                  _Symbol);
      return(0.0);
     }

   double max_lot_allowed = MathFloor(volume_max / volume_step) * volume_step;
   max_lot_allowed        = NormalizeDouble(max_lot_allowed, precision);

   if(max_lot_allowed <= 0.0)
      return(0.0);

   if(normalized_lot > max_lot_allowed)
      normalized_lot = max_lot_allowed;

   if(normalized_lot > volume_max)
      normalized_lot = volume_max;

   normalized_lot = NormalizeDouble(normalized_lot, precision);

   return(normalized_lot);
  }

void OnTick()
  {
   if(HasManagedPositionOpen(_Symbol))
      return;

   // ------------------------------------------------------------------
   // 1. Préparer les données de marché et les indicateurs nécessaires.
   // ------------------------------------------------------------------

   const int values_to_copy = 3;
   double fast_ma_values[values_to_copy];
   double slow_ma_values[values_to_copy];

   ArraySetAsSeries(fast_ma_values, true);
   ArraySetAsSeries(slow_ma_values, true);

   ResetLastError();
   const int fast_copied = CopyBuffer(fast_ma_handle, 0, 0, values_to_copy, fast_ma_values);
   if(fast_copied != values_to_copy)
     {
      PrintFormat("Echec de la copie des données de la moyenne mobile rapide. Code d'erreur : %d", GetLastError());
      return;
     }

   ResetLastError();
   const int slow_copied = CopyBuffer(slow_ma_handle, 0, 0, values_to_copy, slow_ma_values);
   if(slow_copied != values_to_copy)
     {
      PrintFormat("Echec de la copie des données de la moyenne mobile lente. Code d'erreur : %d", GetLastError());
      return;
     }

   // ------------------------------------------------------------------
   // 2. Vérifier les conditions de trading (entrées/sorties, filtres, etc.).
   // ------------------------------------------------------------------

   const double fast_previous     = fast_ma_values[1];
   const double fast_previous_two = fast_ma_values[2];
   const double slow_previous     = slow_ma_values[1];
   const double slow_previous_two = slow_ma_values[2];

   bool buy_signal  = false;
   bool sell_signal = false;

   if(fast_previous > slow_previous && fast_previous_two <= slow_previous_two)
      buy_signal = true;

   if(fast_previous < slow_previous && fast_previous_two >= slow_previous_two)
      sell_signal = true;

   // Les variables buy_signal et sell_signal peuvent être utilisées ici pour gérer les entrées en position.

   // ------------------------------------------------------------------
   // 3. Calculer la taille de position, définir SL/TP et exécuter l'ordre.
   // ------------------------------------------------------------------
  }
